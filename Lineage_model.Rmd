---
title: "Building a new model to assess HPV16 lineage"
author: "Laura Asensio Puig"
date: "24/02/2022"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)

PC_path <- "/home/laura/Dropbox/Lineage_Model/PATH/"
```

## Load and prepare datasets
To build the model we collected samples from NCBI webpage (n = xxx) and from a reference dataset obtained from xxx (n = xxx). Lineage was assessed by the current method called Maximum Likelihood Tree (MLT) and saved in a file called PHENODATA.csv. To the dataset, a new sequence called the “n” sequence was added. This sequence is a “no-information sample”, which will be used to assess poor coverage samples in the “n” group instead to misclassify them in a lineage group.


```{r load and prepare, warning = FALSE}

##########################################
####        LOAD & PREPARE DATA       ####
##########################################

# Define your own path
# PC_path <- "~PATH"

#Load libraries
suppressMessages(library(seqinr)) #read fasta
suppressMessages(library(forcats)) #fct_rev
suppressMessages(library(FactoMineR)) #MCA
suppressMessages(library(factoextra)) #plot MCA 
suppressMessages(library(caret)) #training test algorithms
suppressMessages(library(epitools)) #OR function
suppressMessages(library(gtools)) #create combinations of letters
suppressMessages(library(evaluate)) #save warning messages 
suppressMessages(library(xtable)) #create tables
suppressMessages(library(RColorBrewer)) # palette colors
suppressMessages(library(viridis)) # palette colors
suppressMessages(library(kableExtra)) # nice tables
suppressMessages(library(scales)) #write in scientific notation

# Load internal functions
source(paste(PC_path, "Codes/", "Functions.R", sep = "/"))

# Define colors 
col_cc <- c("#EE7E33", "#9cc653") #For case/control variable
col_lin <- viridis(5) #For Lineage
col_sublin <- viridis(13) #For Sublineage

### Organize Folders ###
# PATH/
# - Codes/
#     -Functions.R
# - Data/
#     -PHENODATA.csv
#     -Aligned/
#       - Aligned_samples.fasta (or .Rdata)
# - Results/

wd_data <- paste(PC_path, "Data/", sep = "" )
wd_aligned <- paste(PC_path, "Data/Aligned/", sep = "" )

## Create Results Folder
files_folder <- "Results/"
if (dir.exists(paste(PC_path, files_folder, sep = ""))==TRUE){
  unlink(paste(PC_path, files_folder, sep = ""), recursive = F)
}
dir.create(paste(PC_path, files_folder, sep = ""))
wd_results <- paste(PC_path, files_folder, sep = "")
rm(files_folder)


###### REFERENCE HPV16 GENOMES #####
#PREVIOUS STEPS: Align HPV genomes using the bash script called: 1_Align_samples.sh

# Function: if Rdata file exist, load it. If not, create a new file from the aligned fasta file
file_name <- "Aligned_samples"
if (file.exists(paste(wd_aligned, file_name, ".Rdata", sep = "")) == F) {
  seq <- seqinr::read.fasta(paste(wd_aligned, file_name, ".fasta", sep = ""), seqtype = "DNA")
  sequences <- getSequence(seq, as.string = FALSE)
  REF_GENOME <- setup.genome.df(sequences)
  REF_GENOME[REF_GENOME == "-"] <- "n"
  sequence_names <- getName(seq, as.string = FALSE)
  sequence_names <- gsub("\\..*","",sequence_names)
  rownames(REF_GENOME) <- sequence_names; rm(seq); rm(sequences); rm(sequence_names);
  #Remove letters that does not belong to the DNA nucleotides (a,c,g,t)
  REF_GENOME[REF_GENOME == "k" | REF_GENOME == "m" | REF_GENOME == "r" | REF_GENOME == "w" | REF_GENOME == "y"] <- "n"
  save(REF_GENOME, file = paste(wd_aligned, file_name, ".Rdata", sep = ""))  
}else{
  load( paste(wd_aligned, file_name, ".Rdata", sep = ""))
}

######  PHENODATA #######
PHENO <- read.csv(paste(wd_data, "PHENODATA.csv", sep= ""), sep = "," )

#Merge Genome with Phenodata information
PHENO$Sample <- gsub(" ", "_", PHENO$Sample)
yy <- match(rownames(REF_GENOME), PHENO$Sample); PHENO<- PHENO[yy,]

###### ADD n SEQUENCE ########
## REQUIRED STEP TO DETECT BAD AND POOR COVERAGE SAMPLES:
if (identical(rownames(REF_GENOME), PHENO$Sample)== TRUE){
  n <- rep("n", ncol(REF_GENOME))
  REF_GENOME <- rbind(REF_GENOME, n)
  rownames(REF_GENOME)[nrow(REF_GENOME)] <- "Sample_N"

  n <- c(rep("n", (ncol(PHENO))))
  PHENO <- data.frame(rbind(as.matrix(PHENO), n))
  rownames(PHENO)[nrow(PHENO)] <- "Sample_N"
  PHENO$Sample <- as.character(PHENO$Sample)
  PHENO[grep("Sample_N", rownames(PHENO)),1] <- "Sample_N"
}

# Show dataset information:
message <- paste("GENOME INFORMATION:\n", 
           nrow(REF_GENOME), "samples with a total lenght of",
           ncol(REF_GENOME), "nucleotides", sep = " ")
par(mfrow=c(1,2),oma = c(0, 0, 4, 0))
barplot(prop.table(table(PHENO$Lineage)), col = col_lin, main = "Lineage")
barplot(prop.table(table(PHENO$Sublineage)), col = col_sublin, main = "Sublineage")
mtext(message, outer = T, cex = 1)
```

## GWAS: Find lineage-related nucleotides

A GWAS (Genome-Wide Association Study) has been performed to determine which HPV16 positions are Lineage-dependent. First, all the mutations for each position have been reported. To be considered as candidates, those mutations must accomplish two conditions: 1) a minimum variant frequency higher than 0.05 to avoid random mutations and 2) a call rate (CR) higher than 95 to avoid positions with a lack of information. Then, each position has been individually tested to see their relationship with a single lineage or a combination of them. To test the relations between nucleotides for a single position and the lineage we used the chi-squared test and then OR has been calculated using GLM with binomial family.

```{r GWAS, warning = F}

##########################################
####           PARAMETERS             ####
##########################################

mvf <- 0.05
callrate <- 90
##########################################

##########################################
####          FIND THE SNPS           ####
##########################################

# Find SNPs between all the lineage combinations (A vs B, A vs C, A vs D .... )
combi <- combn(levels(PHENO$Lineage)[1:4], 2)
setwd(wd_results) #set path 

SNPs_OR_type <- list()
for (i in 1:ncol(combi)){
  Genome <- REF_GENOME[PHENO$Lineage== combi[1,i] | PHENO$Lineage== combi[2,i],]
  pheno <- PHENO[PHENO$Lineage== combi[1,i] | PHENO$Lineage== combi[2,i],]
  Lineage <- pheno$Lineage; Lineage <- as.character(Lineage)
  Genome <- as.data.frame(cbind(Genome, Lineage))
  #Find SNPs
  SNPS <- function(Genome, mvf, callrate){
    ## Find possible candidates (positions with mutations)
    info_seq <- as.data.frame(Genome[, ncol(Genome)])
    rownames(info_seq) <- rownames(Genome)
    Genome <- Genome[,c(1:(ncol(Genome)-1))]
    SNP_candidates <- findSNPs(Genome)
    ## Calculate parametes as MVF and Call.rate
    SNP_parameters <- MVF(SNP_candidates)
    delete <- grep("All", SNP_parameters$minor)
    if (length(delete) >= 1){
      SNP_parameters <- SNP_parameters[-delete,]
      warning("Deleting samples with possible mistakes")
    }
    ## Filter by MVF and CR:
    SNP_QC_param <- filter.snps(SNP_parameters, mvf = mvf, callrate = callrate, show = F)
    ## Remove positions that doesn't fit in the chosen parameters
    pos <- match(SNP_QC_param$position, colnames(Genome))
    pos <- pos[!is.na(pos)]
    genome_candidates <- Genome[, pos]
    ## Calculate OR of the nucleotides vs the genotype:
    GLM <- Single.SNP.association(genome_candidates, info_seq, method = "GLM", rare.variants = TRUE)
    ## Add OR and Pval to the dataframe
    SNP_QC_param_OR <- cbind(SNP_QC_param[match(rownames(GLM),rownames(GLM)),],
                             GLM$OR, GLM$pval, GLM$alleles)
    colnames(SNP_QC_param_OR)[9:11] <- c("OR","pval", "alleles")
    #Remove non-significant p-values:
    the_SNPs <- SNP_QC_param_OR[as.numeric(as.character(SNP_QC_param_OR$pval)) <= 1,]
    return(the_SNPs)
  }
  SNPs_OR_type[[i]] <- SNPS(Genome, mvf, callrate)
}
names(SNPs_OR_type) <- paste(combi[1,], combi[2,], sep = "/")

##################################################################
Annotation <-  read.table(paste(wd_data, "HPV16_GeneMap.txt", sep = ""))
gene_annotation <- read.annotation(Annotation, virus_size = 7906)

#Create a table with all the significant SNPs (for all the lineages) 
df <- do.call(rbind.data.frame, SNPs_OR_type)
df$pval <- as.numeric(as.character(df$pval))
df <- df[df$pval < 0.05,]

df$mvf <- round(df$mvf,2); df$pval <- sapply(df$pval, pvalue.return)
df$OR <- as.numeric(as.character(df$OR)); df$OR <- scientific(df$OR, digits = 3)
colnames(df)[c(3,5)] <- c("#M", "#m")
df <- df[-ncol(df)]

df <-df[order(df$position),]

# #AFEGIR GENES
df$gene <- "empty"
for (i in 1:nrow(df)){
  xx <- gene.annotation(df[i,"position"],gene_annotation)[2]
  df$gene[i] <- as.character(xx[[1]])
}

write.csv(df, paste(wd_results, "SNPs_parameters.csv", sep = ""))
df %>%
  kbl(caption = "Table 1: Lineage-related SNPs") %>%
  kable_classic(full_width = F, html_font = "Calibri", position = "center")

#Save the main positions
positions_for_model <- unique(df$position); positions_for_model <- positions_for_model[!is.na(positions_for_model)]
positions_for_model <- sort(positions_for_model)

#Build a dataframe wiht the main positions and their nucleotides for each sample.
SNPs_for_MODEL <- as.data.frame(REF_GENOME[,as.character(positions_for_model)])
colnames(SNPs_for_MODEL) <- c(positions_for_model)
write.csv(SNPs_for_MODEL, paste(wd_results, "SNP_Genome.csv", sep = ""))
SNPs_for_MODEL[20:25,c(1,9:15)] %>%
  kbl(caption = "Table 2: Part of the SNP_GENOME table, which contains the information for each sample and SNP") %>%
  kable_classic(full_width = F, html_font = "Calibri", position = "center")
```

The GWAS showed a total of `r length(positions_for_model)` SNPs that are significantly related to the HPV16 Lineage. 

## Machine learning to build a new model to assess HPV16-Lineage

Reducing the HPV16 genome (7909 nucleotides) to `r length(positions_for_model)` Lineage-dependent SNPs, we can start building new methods that will require fewer variables but with higher relevance. Those new models will be faster and will allow us to study HPV sequences with poorer sequencing quality.

```{r building a model, warning = F}

##########################################
####         BUILD THE MODELS         ####
##########################################

### PREPARE DATA ### 
ss <- 123456  #set.seed
dataset <- SNPs_for_MODEL
positions <- colnames(dataset)

#Delete SNPs that doesn't belong to any gene
gene_positions <- gene.annotation(positions, gene_annotation)
No_gene_positions <- length(grep(TRUE, gene_positions$gene == "NA"))
positions <- rownames(gene_positions[!gene_positions$gene == "NA",])

# Remove SNPs from dataset
dataset <- dataset[,positions]; #dim(dataset)
colnames(dataset) <- paste("snp", colnames(dataset) , sep = "") 

#Add Lineage (assessed by MLT) to the dataset
if (identical(as.character(PHENO$Sample), rownames(dataset)) == TRUE){
  Lineage <- PHENO$Lineage
  dataset <- cbind(dataset, Lineage)
}

### SPLIT DATASET INTO VALIDATION AND TRAINING-TEST SAMPLES    
#Validation (20% of samples randomly selected)
set.seed(ss)
validation_index <- createDataPartition(dataset$Lineage, p=0.80, list=FALSE)
validation <- dataset[-validation_index,]
sample_number_validation <- nrow(validation) # 128 samples for validation

#Training-test dataset
dataset <- dataset[validation_index,]
# nrow(dataset) # 520 samples for training-test 
sample_number_trainingtest <- nrow(dataset)


##########################################
####         TRAINING-TEST            ####
##########################################

### USE 10-FOLD CROSS VALIDATION
# We will 10-fold crossvalidation to estimate accuracy.
# This will split our dataset into 10 parts (number = 10), train in 9 and test on 1 and release for all combinations
# of train-test splits. We will also repeat the process 3 times (repeats = 3) for each algorithm.

control <- trainControl(method="cv", number= 10, repeats = 2) 
metric <- "Accuracy"

### BUILD MODELS
## a) linear algorithms
# LDA (Failed)
# fit.lda <- caret::train(Lineage~., data=dataset, method="lda", metric=metric, trControl=control)

## b) nonlinear algorithms
# CART
set.seed(ss)
fit.cart <- caret::train(Lineage~., data=dataset, method="rpart", metric=metric, trControl=control)

# kNN
set.seed(ss)
fit.knn <- caret::train(Lineage~., data=dataset, method="knn", metric=metric, trControl=control)

## c) advanced algorithms
# SVM
set.seed(ss)
fit.svm <- caret::train(Lineage~., data=dataset, method="svmRadial", metric=metric, trControl=control)

# Random Forest
set.seed(ss)
fit.rf <- caret::train(Lineage~., data=dataset, method="rf", metric=metric, trControl=control)
```
A total of `r No_gene_positions` SNPs were excluded from the model since they don't belong to any gene. 

## Which is the best model? 

To assess HPV16 lineage, we built 5 different models with the `r (length(positions_for_model)-No_gene_positions)` Lineage-related SNPs and based on different training-test algorithms: Random Forest (RF), Support Vector Machine (SVM), K-nearest neighbour (KNN), Classification  and  Regression Trees (CART), and latent Dirichlet allocation (LDA). 

```{r selecting best model, warning = F}

### SELECT THE BEST METHOD
# Model accuracy: 
results <- resamples(list(cart=fit.cart, knn=fit.knn, svm=fit.svm, rf=fit.rf))
summary(results)

#Plot accuracy and kappa
dotplot(results) 
```
SVM, KNN and RF showed similar accuracy and kappa values and LDA-based model failed. 

## Validation

The 80% of the samples (n = `r  nrow(dataset)`) were used to train and test the model, and the remaining 20% (n = `r  nrow(validation)`) has been used to check the sensitivity and specificity of the models. 

```{r validation, warning = F}

#The model only include the known nucleotides per snp found in the reference dataset (GWAS), however, some times is possible that a new mutation is present in one of those SNPs. This function changes random mutations per one "n". 
Modifications <- NULL
if (length(grep("snp", as.character(evaluate("predict(fit.rf, validation)")[[2]]))) == 0){
  Modifications <- "No modifications were applied to the dataset"
}else{
    while (grep("snp", as.character(evaluate("predict(fit.rf, validation)")[[2]])) >= 1) {
      message <-  as.character(evaluate("predict(fit.rf, validation)")[[2]])
      snp <- sub(".*factor ", "", message)
      snp <- sub("\\ has.*", "", snp)
      nt <- sub(".*levels ", "", message)
      nt <- substr(nt, 1, 1)
      ID <- rownames(validation)[grep(nt, validation[, snp])]
      # show(ID)
      if (length(ID) == 1){
        Modifications <- rbind(Modifications, c(snp, nt, ID))
        levels(validation[,snp]) <- c(levels(validation[,snp]),"n")
        validation[ID, snp] <- "n"
      }else{
        for (i in 1:length(ID)){
          Modifications <- rbind(Modifications, c(snp, nt, ID[i]))
          levels(validation[,snp]) <- c(levels(validation[,snp]),"n")
          validation[ID[i], snp] <- "n"
        }
      }
    }
}

if (is.character(Modifications)== T){ show(Modifications)
}else{ Modifications <- as.data.frame(Modifications); colnames(Modifications) <- c("SNP", "nt", "ID")
  show(Modifications)}

### VALIDATE THE MODEL WITH THE TRAINING TEST-DATA
# dataset

n_sample <- rep("n", ncol(validation))
validation <- as.data.frame(rbind(as.matrix(validation), n_sample))

## 1) Prediction and validation with SVM and KNN
set.seed(ss)
predictions.svm <- predict(fit.svm, validation[,1:(ncol(validation)-1)])
set.seed(ss)
predictions.knn <- predict(fit.knn, validation[,1:(ncol(validation)-1)])

par(mfrow=c(1,2),oma = c(0, 0, 4, 0))
plot.cm(predictions.svm, validation$Lineage, rescales = F)
mtext("SVM", outer = F, cex = 1)
plot.cm(predictions.knn, validation$Lineage, rescales = F)
mtext("KNN", outer = F, cex = 1)
mtext("Validation Matrix", outer = T, cex = 2)

## 2) Prediction and validation with RF
set.seed(ss)
predictions.rf <- predict(fit.rf, validation[,1:(ncol(validation)-1)])

par(mfrow=c(1,1),oma = c(0, 0, 2, 0))
plot.cm(predictions.rf, validation$Lineage, rescales = F)
mtext("Random Forest Validation Matrix", outer = T, cex = 2)

save(fit.rf, file = paste(wd_results, "HPV16_Lineage_MODEL_rf.Rdata", sep = ""))
```
KNN, SVM and RF based models showed similar accuracy and kappa values, and although SVM and KNN where placed in a top positions, we opt to chose Random Forest, since it is the unique model that could assess correctly all the samples, showing a perfect validation matrix.


